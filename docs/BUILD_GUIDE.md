# Build Guide - Customizing fdebug for Your Project

## Overview

The `build.rs` file is a Cargo build script that runs **before** compilation to generate runtime seed entropy. Understanding and customizing this file is essential for developers who want to tailor fdebug's anti-debug protection to their specific needs.

This guide explains:
- How `build.rs` works with fdebug's Seed Orchestrator
- How to customize entropy generation
- How to integrate additional build-time secrets
- Best practices for different deployment scenarios
- Common customization patterns

---

## Understanding fdebug's Build System

### The Three-Shard Entropy System

fdebug's protection relies on three entropy sources that combine at **runtime**:

1. **Build-Time Seed (Shard 1)** - Generated by `build.rs`
   - Unique per binary compilation
   - Embedded in compiled binary via `include!()` macro
   - Changes every build

2. **Hardware Entropy (Shard 2)** - Generated at runtime
   - CPU-specific CPUID fingerprint (vendor, model, features)
   - Hardware-dependent
   - Cannot be modified after compilation

3. **PE Integrity Hash (Shard 3)** - Generated at runtime
   - Checksum of executable `.text` section
   - Changes if code is patched, injected, or hooked
   - Detects tampering

### How `build.rs` Fits In

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  $ cargo build                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  build.rs runs (pre-compilation)        â”‚
â”‚  â€¢ Generates random seed (Shard 1)      â”‚
â”‚  â€¢ Creates dynamic_seed.rs in OUT_DIR   â”‚
â”‚  â€¢ Sets build environment variables     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Rust compiler compiles project         â”‚
â”‚  â€¢ Includes dynamic_seed.rs             â”‚
â”‚  â€¢ Embeds Shard 1 in binary             â”‚
â”‚  â€¢ Generates executable                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Application runs                       â”‚
â”‚  â€¢ Reads Shard 1 from binary            â”‚
â”‚  â€¢ Detects Shard 2 at runtime (CPUID)   â”‚
â”‚  â€¢ Computes Shard 3 at runtime (PE)     â”‚
â”‚  â€¢ Combines: SEED = avalanche_mix(S1 âŠ• S2 âŠ• S3) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Default build.rs Implementation

Here's the current default `build.rs`:

```rust
// build.rs - Default fdebug build script

#![allow(unused_imports)]

use std::env;
use std::fs::File;
use std::io::Write;
use std::path::Path;

fn main() {
    // Generate a random seed at build time for polymorphic opcodes
    let dynamic_seed = generate_random_seed_u32();

    // Create the dynamic_seed.rs file in OUT_DIR so it can be included
    let out_dir = env::var_os("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("dynamic_seed.rs");

    let mut f = File::create(&dest_path).unwrap();

    // Just write the literal value so it can be included as an expression
    writeln!(f, "0x{:08X}u32", dynamic_seed).unwrap();

    // Tell cargo to rerun this build script if something changes
    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=src/protector/tiny_vm.rs");
}

// Function to generate a pseudo-random 32-bit seed based on build environment
fn generate_random_seed_u32() -> u32 {
    use std::time::{SystemTime, UNIX_EPOCH};

    // Get current time in nanoseconds as a source of randomness
    let now = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .expect("Time went backwards")
        .as_nanos();

    // Use multiple sets of bits from the timestamp mixed with environmental factors
    let mut seed = (now & 0xFFFFFFFF) as u32;

    // Mix with upper bits for more entropy
    seed ^= (now >> 32) as u32;

    // Add some environmental entropy
    if let Ok(pwd) = env::current_dir() {
        let h = pwd.to_string_lossy().bytes().fold(0u32, |acc, b| {
            acc.rotate_left(7).wrapping_add(b as u32)
        });
        seed ^= h;
    }

    // Add cargo profile and manifest data to the mix
    if let Ok(profile) = env::var("PROFILE") {
        seed ^= profile.bytes().fold(0u32, |acc, b| acc.wrapping_add(b as u32));
    }

    // Mix in manifest directory to ensure different clones have different seeds
    if let Ok(manifest) = env::var("CARGO_MANIFEST_DIR") {
        let h = manifest.bytes().fold(0u32, |acc, b| {
            acc.rotate_right(5) ^ (b as u32)
        });
        seed ^= h;
    }

    // Ensure the seed is not zero
    if seed == 0 {
        seed = 0x9A3F_C5D7; // Default fallback
    }

    seed
}
```

### What This Does

1. **Generates Random Seed**: Creates a unique 32-bit value based on:
   - Current system time (nanoseconds)
   - Build directory path
   - Cargo profile (debug/release)
   - Manifest directory location

2. **Creates dynamic_seed.rs**: Writes the seed as a literal constant

3. **Embeds in Binary**: The seed is included at compile-time and becomes part of your executable

---

## Customization Patterns

### Pattern 1: Deterministic Seed (Testing/CI/CD)

When you need **reproducible** builds (like in continuous integration), use an environment variable:

```rust
// build.rs - Deterministic seed variant

use std::env;
use std::fs::File;
use std::io::Write;
use std::path::Path;

fn main() {
    // Check for CI_BUILD_SEED environment variable
    // In CI/CD pipeline, set: export CI_BUILD_SEED=0x12345678
    let dynamic_seed = if let Ok(seed_str) = env::var("CI_BUILD_SEED") {
        // Parse seed from environment variable (e.g., "0x12345678")
        u32::from_str_radix(seed_str.trim_start_matches("0x"), 16)
            .expect("Invalid CI_BUILD_SEED format. Use: 0xHEXVALUE")
    } else {
        // Fall back to random generation if not in CI
        generate_random_seed_u32()
    };

    // Rest of the code remains the same
    let out_dir = env::var_os("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("dynamic_seed.rs");
    let mut f = File::create(&dest_path).unwrap();
    writeln!(f, "0x{:08X}u32", dynamic_seed).unwrap();

    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=src/protector/tiny_vm.rs");
}

// ... rest of implementation ...
```

**Usage in CI/CD:**
```bash
# In your CI pipeline (GitHub Actions, GitLab CI, etc.)
export CI_BUILD_SEED=0xDEADBEEF
cargo build --release
```

---

### Pattern 2: Enhanced Entropy (Production Deployments)

Add more entropy sources for maximum randomness:

```rust
// build.rs - High-entropy variant

use std::env;
use std::fs::File;
use std::io::Write;
use std::path::Path;
use std::time::{SystemTime, UNIX_EPOCH};
use std::process::Command;

fn main() {
    let dynamic_seed = generate_high_entropy_seed();

    let out_dir = env::var_os("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("dynamic_seed.rs");
    let mut f = File::create(&dest_path).unwrap();
    writeln!(f, "0x{:08X}u32", dynamic_seed).unwrap();

    println!("cargo:rerun-if-changed=build.rs");
}

fn generate_high_entropy_seed() -> u32 {
    let mut seed = 0u32;

    // Source 1: System time
    if let Ok(duration) = SystemTime::now().duration_since(UNIX_EPOCH) {
        let nanos = duration.as_nanos();
        seed ^= (nanos & 0xFFFFFFFF) as u32;
        seed ^= (nanos >> 32) as u32;
    }

    // Source 2: Build environment variables
    if let Ok(profile) = env::var("PROFILE") {
        seed = seed.wrapping_mul(31);
        seed ^= profile.bytes().fold(0u32, |a, b| a.wrapping_add(b as u32));
    }

    // Source 3: Git commit hash (if available)
    if let Ok(output) = Command::new("git")
        .args(&["rev-parse", "--short", "HEAD"])
        .output()
    {
        if output.status.success() {
            let commit_hash = String::from_utf8_lossy(&output.stdout);
            seed = seed.wrapping_mul(37);
            seed ^= commit_hash.trim().bytes().fold(0u32, |a, b| a.wrapping_add(b as u32));
        }
    }

    // Source 4: Cargo manifest directory
    if let Ok(manifest) = env::var("CARGO_MANIFEST_DIR") {
        seed = seed.wrapping_mul(41);
        seed ^= manifest.bytes().fold(0u32, |a, b| {
            a.rotate_right(3).wrapping_add(b as u32)
        });
    }

    // Source 5: Out directory (always different for parallel builds)
    if let Ok(out_dir) = env::var("OUT_DIR") {
        seed = seed.wrapping_mul(43);
        seed ^= out_dir.bytes().fold(0u32, |a, b| {
            a.rotate_left(5) ^ (b as u32)
        });
    }

    // Ensure non-zero
    if seed == 0 {
        seed = 0xC0DE_FEED;
    }

    seed
}
```

---

### Pattern 3: Custom Environment Secrets

Mix custom secrets from build environment:

```rust
// build.rs - Custom secrets variant

use std::env;
use std::fs::File;
use std::io::Write;
use std::path::Path;

fn main() {
    let dynamic_seed = generate_seed_with_custom_secret();

    let out_dir = env::var_os("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("dynamic_seed.rs");
    let mut f = File::create(&dest_path).unwrap();
    writeln!(f, "0x{:08X}u32", dynamic_seed).unwrap();

    println!("cargo:rerun-if-changed=build.rs");
}

fn generate_seed_with_custom_secret() -> u32 {
    // Read a custom secret from environment or .env file
    // You could also use the `dotenv` crate to load from .env file
    
    let custom_secret = env::var("FDEBUG_BUILD_SECRET")
        .unwrap_or_else(|_| {
            eprintln!("âš ï¸  Warning: FDEBUG_BUILD_SECRET not set, using default entropy");
            String::new()
        });

    let mut seed = 0u32;

    // Mix custom secret if provided
    if !custom_secret.is_empty() {
        seed ^= custom_secret.bytes().fold(0u32, |acc, b| {
            acc.rotate_left(11).wrapping_add(b as u32)
        });
    }

    // Mix with standard entropy
    if let Ok(manifest) = env::var("CARGO_MANIFEST_DIR") {
        seed ^= manifest.bytes().fold(0u32, |acc, b| {
            acc.rotate_right(7) ^ (b as u32)
        });
    }

    if seed == 0 {
        seed = 0xF00D_CAFE;
    }

    seed
}
```

**Usage:**
```bash
# Set custom secret before building
export FDEBUG_BUILD_SECRET="my-super-secret-entropy-string"
cargo build --release
```

---

### Pattern 4: Different Seeds for Different Profiles

Use different entropy strategies for debug vs release builds:

```rust
// build.rs - Profile-aware variant

use std::env;
use std::fs::File;
use std::io::Write;
use std::path::Path;
use std::time::{SystemTime, UNIX_EPOCH};

fn main() {
    let profile = env::var("PROFILE").unwrap_or_else(|_| "unknown".to_string());

    // Choose seed generation strategy based on profile
    let dynamic_seed = match profile.as_str() {
        "release" => {
            // Maximum entropy for production releases
            generate_high_entropy_seed()
        }
        "debug" => {
            // Faster generation for development
            generate_fast_seed()
        }
        _ => {
            // Custom profile
            generate_random_seed_u32()
        }
    };

    let out_dir = env::var_os("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("dynamic_seed.rs");
    let mut f = File::create(&dest_path).unwrap();
    writeln!(f, "0x{:08X}u32", dynamic_seed).unwrap();

    // Log which strategy was used
    println!("cargo:warning=fdebug: Generated seed for [{}] profile", profile);
    println!("cargo:rerun-if-changed=build.rs");
}

fn generate_high_entropy_seed() -> u32 {
    // For release builds - maximum entropy
    let now = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_nanos();
    
    let mut seed = (now & 0xFFFFFFFF) as u32;
    seed ^= (now >> 32) as u32;
    seed ^= (now >> 64) as u32;
    
    seed
}

fn generate_fast_seed() -> u32 {
    // For debug builds - simpler, faster
    let now = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_nanos();
    
    ((now & 0xFFFFFFFF) as u32).wrapping_mul(0x9E37_79B9)
}

fn generate_random_seed_u32() -> u32 {
    // Default implementation
    0xDEAD_BEEF
}
```

---

## Integration with Other Build Systems

### Pattern 5: Custom Features

Enable/disable entropy sources via Cargo features:

```rust
// build.rs - Feature-gated entropy

use std::env;
use std::fs::File;
use std::io::Write;
use std::path::Path;

fn main() {
    let dynamic_seed = if cfg!(feature = "high_entropy") {
        // Use maximum entropy for high-security builds
        generate_high_entropy_seed()
    } else if cfg!(feature = "deterministic") {
        // Use deterministic seed for testing
        generate_deterministic_seed()
    } else {
        // Default random seed
        generate_random_seed_u32()
    };

    let out_dir = env::var_os("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("dynamic_seed.rs");
    let mut f = File::create(&dest_path).unwrap();
    writeln!(f, "0x{:08X}u32", dynamic_seed).unwrap();

    println!("cargo:rerun-if-changed=build.rs");
}

// ... implementation ...
```

**Usage with Cargo.toml:**
```toml
[features]
high_entropy = []  # Maximum entropy for production
deterministic = [] # Fixed seed for testing
```

**Building with features:**
```bash
# Maximum entropy build
cargo build --release --features high_entropy

# Deterministic build (for testing)
cargo build --features deterministic

# Default build
cargo build
```

---

## Best Practices

### âœ… DO

1. **Ensure Unique Seeds Per Build**
   - Each compilation should generate a different seed (unless using deterministic mode)
   - This prevents seed extraction and reuse

2. **Include Timestamp**
   - System time provides natural entropy variation
   - Different build times = different seeds

3. **Mix Multiple Entropy Sources**
   - Never rely on a single source
   - Combine time, filesystem paths, environment variables

4. **Document Your Customizations**
   - Add comments explaining why you chose specific entropy sources
   - This helps future maintainers understand the build strategy

5. **Test Reproducibility**
   ```bash
   # Build twice and verify different executables
   cargo build --release
   md5sum target/release/fdebug.exe > hash1.txt
   
   cargo clean
   cargo build --release
   md5sum target/release/fdebug.exe > hash2.txt
   
   diff hash1.txt hash2.txt  # Should be different
   ```

6. **Use Environment Variables for Secrets**
   - Keep sensitive seed material in environment variables
   - Never hardcode production secrets in source code

7. **Validate Seed Quality**
   - Ensure seed is non-zero
   - Check for reasonable bit distribution

### âŒ DON'T

1. **Don't Use Static Seeds**
   - `0x12345678` in source code defeats the purpose
   - Seeds must vary between builds

2. **Don't Ignore Entropy Sources**
   - Single-source entropy is weak
   - Mix multiple independent sources

3. **Don't Build Without Seed**
   - Every compilation must include a unique seed
   - Missing seed = default seed = predictable

4. **Don't Commit .env Files**
   - If using environment variables for secrets, add .env to .gitignore
   - Keep secrets out of version control

5. **Don't Mix Release and Debug Seeds**
   - Use consistent entropy generation strategy
   - Different profiles can use different strategies, but be intentional

6. **Don't Forget to Rerun on Changes**
   ```rust
   // Always include these
   println!("cargo:rerun-if-changed=build.rs");
   println!("cargo:rerun-if-changed=src/protector/");
   ```

---

## Troubleshooting

### Build Script Fails

**Problem**: `cargo build` fails with "build.rs error"

**Solution**:
```rust
// Wrap file operations in proper error handling
match std::fs::File::create(&dest_path) {
    Ok(mut f) => {
        let _ = writeln!(f, "0x{:08X}u32", dynamic_seed);
    }
    Err(e) => {
        eprintln!("Failed to create dynamic_seed.rs: {}", e);
        panic!("Build script failed");
    }
}
```

### Seed Always Same

**Problem**: Multiple builds produce the same binary

**Solution**: Check entropy sources
```bash
# Verify environment variables are being used
cargo build -vv 2>&1 | grep "dynamic_seed"

# Try cleaning and rebuilding
cargo clean
cargo build

# If still same, add more entropy sources to build.rs
```

### Build Too Slow

**Problem**: Build takes a long time

**Solution**: Reduce entropy source overhead
```rust
// Instead of multiple subprocess calls
// Just use built-in entropy
let now = SystemTime::now()
    .duration_since(UNIX_EPOCH)
    .unwrap()
    .as_nanos();
let seed = ((now & 0xFFFFFFFF) as u32) ^ ((now >> 32) as u32);
```

---

## Real-World Examples

### Example 1: Secure CI/CD Build

```rust
// build.rs - CI/CD optimized

use std::env;
use std::fs::File;
use std::io::Write;
use std::path::Path;
use std::time::{SystemTime, UNIX_EPOCH};

fn main() {
    let dynamic_seed = if env::var("CI").is_ok() {
        // In CI environment: use git hash for reproducibility per commit
        get_ci_seed()
    } else {
        // Local development: use random seed
        generate_random_seed_u32()
    };

    write_seed(&dynamic_seed);
}

fn get_ci_seed() -> u32 {
    // Different seed per commit, same seed for same commit
    if let Ok(output) = std::process::Command::new("git")
        .args(&["rev-parse", "HEAD"])
        .output()
    {
        if output.status.success() {
            let hash = String::from_utf8_lossy(&output.stdout);
            return hash.chars()
                .take(8)
                .map(|c| c as u32)
                .fold(0u32, |a, b| a.wrapping_mul(31).wrapping_add(b));
        }
    }
    0xDEF4_C0DE
}

fn generate_random_seed_u32() -> u32 {
    let now = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_nanos();
    ((now & 0xFFFFFFFF) as u32) ^ ((now >> 32) as u32)
}

fn write_seed(seed: &u32) {
    let out_dir = env::var_os("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("dynamic_seed.rs");
    let mut f = File::create(&dest_path).unwrap();
    writeln!(f, "0x{:08X}u32", seed).unwrap();
    println!("cargo:rerun-if-changed=build.rs");
}
```

### Example 2: Development Build with Logging

```rust
// build.rs - Developer-friendly variant

use std::env;
use std::fs::File;
use std::io::Write;
use std::path::Path;
use std::time::{SystemTime, UNIX_EPOCH};

fn main() {
    let dynamic_seed = generate_random_seed_u32();

    // Log seed info for developer debugging
    eprintln!("ðŸ” fdebug seed generated: 0x{:08X}", dynamic_seed);
    eprintln!("   Every build will use a different seed");
    eprintln!("   This ensures polymorphic protection");

    let out_dir = env::var_os("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("dynamic_seed.rs");
    let mut f = File::create(&dest_path).unwrap();
    writeln!(f, "0x{:08X}u32", dynamic_seed).unwrap();

    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=src/protector/");
}

fn generate_random_seed_u32() -> u32 {
    let now = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_nanos();
    
    let mut seed = (now & 0xFFFFFFFF) as u32;
    seed ^= (now >> 32) as u32;
    
    // Add path entropy
    if let Ok(pwd) = env::current_dir() {
        seed ^= pwd.to_string_lossy().bytes().fold(0u32, |a, b| {
            a.rotate_left(7).wrapping_add(b as u32)
        });
    }
    
    if seed == 0 {
        seed = 0xF00_DBEEF;
    }
    
    seed
}
```

---

## Summary

**Key Takeaways:**

1. **`build.rs` generates Shard 1** of the three-shard entropy system
2. **Unique seeds per build** provide polymorphism across users
3. **Multiple entropy sources** prevent seed prediction
4. **Customization patterns** exist for different deployment scenarios
5. **Best practices** ensure robust and secure builds

**Next Steps:**

- Choose a customization pattern that fits your deployment model
- Test reproducibility in your build environment
- Document your entropy strategy for future maintainers
- Monitor build logs to verify seed generation

---

## Additional Resources

- [Architecture Guide - Seed Orchestrator (Layer 5)](ARCHITECTURE_LAYER5.md)
- [API Reference - get_dynamic_seed()](reference_guide_NEW.md)
- [Complete Integration Guide](FDEBUG_COMPLETE_GUIDE.md)
- [Implementation Guide - Design Patterns](implementation_guide_NEW.md)
