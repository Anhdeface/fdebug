# Documentation Updates - Seed Orchestrator Architecture

## Summary of Code Changes

The fdebug module has been updated with a new **Seed Orchestrator** architecture that replaces the static `DYNAMIC_SEED` constant with **runtime seed reconstruction** from three independent entropy sources:

### What Changed:

1. **Old API:**
   ```rust
   const DYNAMIC_SEED: u32 = 0x12AB34CD;  // Static, vulnerable to analysis
   ```

2. **New API:**
   ```rust
   pub fn get_dynamic_seed() -> u32      // Runtime-reconstructed
   pub fn get_dynamic_seed_u8() -> u8    // u8 variant for compatibility
   ```

### The Three Entropy Shards:

**Shard 1: Build-Time Seed**
- Generated by `build.rs` at compile time
- Random 32-bit value embedded via `include!()` macro
- Different for every build
- Located in: `seed_orchestrator.rs` → `BUILD_TIME_SEED`

**Shard 2: Hardware Entropy**  
- Extracted from CPU CPUID instruction
- Processor-specific fingerprint (vendor, model, features, stepping)
- Cached after first access
- Located in: `hardware_entropy.rs` → `get_hardware_entropy()`

**Shard 3: PE Integrity Hash**
- Checksum of `.text` section (all executable code)
- Detects code tampering, patches, DLL injection
- Computed on-demand with caching
- Located in: `pe_integrity.rs` → `get_text_section_hash()`

### Reconstruction Formula:

```
FINAL_SEED = avalanche_mix(BUILD_SEED ^ HW_ENTROPY ^ PE_HASH)
```

Where `avalanche_mix()` is the MurmurHash3 finalizer that ensures bit avalanche effect.

### Performance Impact:

- **First call**: ~50-100 microseconds (CPUID + PE parsing)
- **Cached calls**: ~1-10 nanoseconds (OnceLock atomic read)
- **Overall**: Negligible overhead after first call

---

## Documentation Updates Needed

### 1. architecture_guide_NEW.md

**Section 2.2: Polymorphic Opcodes**
- Change from: "Generated at compile time using auto_op!()"
- Change to: "Generated dynamically using auto_op!() with runtime-reconstructed seed"
- Add subsection 2.2.1 explaining the Seed Orchestrator
- Explain three entropy shards and reconstruction formula
- Add performance metrics
- Add attack defense examples

**New Section 5: Architecture Layer 5 - Seed Orchestrator**
- Explain the problem with static seeds
- Detail the three-shard architecture
- Show reconstruction and avalanche mixing
- Explain caching strategy
- Show integration points with other layers

**Update Summary Section**
- Change from "four concentric layers" to "five concentric layers"
- Add Entropy layer at the foundation
- Update table with new layer

### 2. reference_guide_NEW.md

**Quick Start Section**
- Update examples from `DYNAMIC_SEED` to `get_dynamic_seed()`
- Add note about runtime reconstruction
- Show how seed is used in Protector::new()

**Core API Reference**
- Add documentation for:
  - `get_dynamic_seed()` → u32
  - `get_dynamic_seed_u8()` → u8
  - `SeedOrchestrator::reconstruct()` (internal)
- Update examples showing new API usage

**Advanced Configuration Section**
- Add section on seed debugging
- Show how to inspect reconstructed seed
- Explain caching and when seed is recomputed

**FAQ Section**
- Add Q&A about seed uniqueness per user
- Explain why static seeds are vulnerable
- Detail attack scenarios and defenses

### 3. implementation_guide_NEW.md

**Pattern 1: The Shield Pattern**
- Update code examples from `DYNAMIC_SEED` to `get_dynamic_seed()`
- Explain how dynamic seed improves protection

**Real-World Use Cases**
- Update all examples showing seed usage
- Software Licensing: Use runtime-reconstructed seed
- API Key Protection: Seed affects encryption
- Sensitive Data: Seed-dependent corruption

**Integration Strategies**
- Update Strategy 1: Show how to handle runtime seed reconstruction
- Add section on seed caching benefits
- Explain selective protection based on seed availability

**Performance Optimization**
- Add Optimization 4: Seed Orchestrator caching
- Explain first-access overhead
- Show cost/benefit analysis

---

## Code Examples to Update

### Example 1: Basic Protection

**Old:**
```rust
use fdebug::protector::{Protector, DYNAMIC_SEED};

let protector = Protector::new(DYNAMIC_SEED);
```

**New:**
```rust
use fdebug::protector::{Protector, get_dynamic_seed};

let seed = get_dynamic_seed();  // Runtime-reconstructed from three sources
let protector = Protector::new(seed);
```

### Example 2: Secure Operations

**Old:**
```rust
let key = DYNAMIC_SEED ^ some_value;
```

**New:**
```rust
let key = get_dynamic_seed() ^ some_value;  // Runtime-reconstructed
```

### Example 3: Seed Inspection

**New (demonstrate capabilities):**
```rust
use fdebug::protector::{get_dynamic_seed, get_dynamic_seed_u8};

let seed_u32 = get_dynamic_seed();
let seed_u8 = get_dynamic_seed_u8();

println!("[*] Seed (u32): 0x{:08X}", seed_u32);
println!("[*] Seed (u8):  0x{:02X}", seed_u8);
```

---

## Integration Points

The Seed Orchestrator feeds into multiple systems:

1. **TinyVM Opcodes**
   - `auto_op!()` macro uses `get_dynamic_seed()`
   - Every opcode is derived from reconstructed seed
   - Polymorphic per build and per hardware platform

2. **SipHash Constants**
   - Dynamic initialization vectors in `global_state.rs`
   - Constants are initialized from reconstructed seed
   - Integrity hash uses seed-dependent values

3. **Shard Masks**
   - `SHARD_MASKS[16]` derived from `get_dynamic_seed()`
   - Each mask is unique to build and hardware
   - Lazy initialization on first access

4. **String Encryption**
   - `enc_str!()` and `enc_string!()` macros
   - Decryption key derived from reconstructed seed
   - File path strings are dynamically decrypted

---

## Module Structure

```
src/protector/
├── seed_orchestrator.rs (NEW - 263 lines)
│   ├── SeedOrchestrator (orchestrates entropy sources)
│   ├── get_dynamic_seed() (public API)
│   ├── get_dynamic_seed_u8() (public API)
│   └── OnceLock cache for performance
│
├── hardware_entropy.rs (Windows-specific)
│   ├── get_hardware_entropy()
│   └── CPUID fingerprinting
│
├── pe_integrity.rs (Windows-specific)
│   ├── get_text_section_hash()
│   └── Code section checksum
│
├── mod.rs
│   └── re-exports seed_orchestrator functions
│
├── anti_debug.rs
│   └── uses reconstructed seed for VM initialization
│
├── tiny_vm.rs
│   ├── auto_op!() macro (uses get_dynamic_seed())
│   └── enc_str!() macros
│
├── global_state.rs
│   ├── get_shard_mask() (uses get_dynamic_seed())
│   └── SipHash constants
│
└── decoy_system.rs
    └── watches for code patches (affects PE_HASH)
```

---

## Testing Validation

The seed reconstruction can be tested:

```rust
#[test]
fn test_seed_reconstruction_caching() {
    let seed1 = get_dynamic_seed();
    let seed2 = get_dynamic_seed();
    assert_eq!(seed1, seed2, "Should be cached and stable");
}

#[test]
fn test_seed_non_zero() {
    let seed = get_dynamic_seed();
    assert_ne!(seed, 0, "Seed should not be zero");
}

#[test]
fn test_three_shards_all_needed() {
    // If any shard changes, final seed changes completely
    // due to avalanche mixing
}
```

---

## Vibe & Writing Style Consistency

The existing documentation maintains these stylistic elements that should be preserved:

1. **Explanatory depth**: Detailed explanations with examples
2. **Visual hierarchies**: Tables, code blocks, nested sections
3. **Attack/Defense framing**: Shows how each layer defeats attacks
4. **Technical accuracy**: Precise descriptions of mechanisms
5. **Practical examples**: Real-world code patterns
6. **Emoji usage** (minimal): ✅ for good practices, ❌ for bad practices
7. **Narrative flow**: Builds from simple to complex concepts


---

## Mandatory Anti-Dump Integration (Zero-Bypass)

New hardening phase ensuring Anti-Dump protection is strictly enforced and unbypassable.

### What Changed:

1.  **Mandatory Macro Enforcement**
    - The `setup_anti_debug!` macro now explicitly calls `init_anti_dump()` before creating the Protector.
    - `Protector::new()` is still available but usage via macro is now the standard to ensure initialization.

2.  **Stealth Verification Loop (`run_secure`)**
    - **Logic**: Every call to `run_secure()` now checks if the PE Header (MZ signature) is erased.
    - **Failure State**: If headers are found (meaning Anti-Dump failed or was skipped), the system triggers `poison_encryption_on_dump_attempt()`.
    - **Behavior**: Silent corruption of `GLOBAL_ENCRYPTION_KEY`. No crashes, just garbage data.

3.  **Entropy Erasure**
    - **Before**: Headers erased with zeros.
    - **After**: Headers erased with **random entropy** derived from `KUSER_SHARED_DATA`.
    - **Benefit**: Defeats reconstruction tools that look for null-byte blocks to identify header locations.

4.  **Pure FFI (Zero Dependency)**
    - Replaced `windows` crate usage in `decoy_system.rs` with `extern "system"` blocks.
    - Reduces binary size and removes easy-to-fingerprint imports.

5.  **Global Kill-Switch**
    - If a dump attempt is detected, `DIAGNOSTIC_MODE` is atomic-swapped to `false`.
    - Attacker is instantly blinded (no logs) during the attack analysis.


---

## Latest Update: TinyVM Refactoring & Anti-Dump Hardening

### Summary of Code Changes

The core Obfuscation (Layer 3) and Integrity (Layer 4) protection logic has been significantly upgraded to defeat modern dynamic analysis and dumping tools.

### What Changed:

#### 1. TinyVM Architecture Overhaul (Randomized V-Table)
- **Problem**: Previous VM used a large `match` statement for opcode dispatch, which compilers optimize into a jump table or binary search tree. Static analysis tools (IDA/Ghidra) could easily reconstruct the Control Flow Graph (CFG).
- **Solution**: Implemented **Indirect Threading** with a **Randomized V-Table**.
    - **LTP Mapping**: A Logic-to-Physical (LTP) map translates logical opcodes to physical handler addresses.
    - **Runtime Shuffling**: The V-Table is shuffled at runtime using a seeded PRNG (`Xorshift32`).
    - **Fail-Deadly**: If a suspicious seed (e.g., 0) is detected, the LTP map is initialized with chaotic entropy (RDTSC + ASLR), causing the VM to execute wrong handlers silently instead of crashing.

#### 2. Advanced Rolling Key Decryption
- **Problem**: Simple XOR encryption is vulnerable to known-plaintext attacks.
- **Solution**: Implemented **Multi-Stage State Mixing**.
    - **Non-Linear Feedback**: `key = (key + raw).wrapping_mul(0x1F) ^ rot(key, 3) ^ global_entropy`.
    - **Position Dependent**: Decoding now depends on the instruction pointer (`VIP`), preventing frequency analysis of identical instructions.
    - **Macro Sync**: The `dynamic_str!` macro was updated to perform the exact inverse mathematical transform at compile time.

#### 3. Anti-Dump Hardening (Selective PE Erasure)
- **Problem**: Complete PE header erasure caused crashes with legitimate Windows APIs (e.g., `GetModuleHandle`, CRT initialization).
- **Solution**: **Surgical/Selective Erasure**.
    - **Preserved**: DOS Header (`MZ` signature) to maintain verifiable module state.
    - **Corrupted**: NT Signature, `AddressOfEntryPoint`, `SizeOfImage`, and `SectionHeaders` (Name/VirtualSize).
    - **Entropy**: Fields are overwritten with high-entropy random data (from `KUSER_SHARED_DATA`) instead of zeros, confusing pattern-matching dumpers.

### Documentation Updates Needed

#### 1. architecture_guide_NEW.md
- **Section 2.2**: Update to reflect "Randomized V-Table" and "Indirect Threading".
- **Section 2.5**: Replace `match` statement example with "Trampoline" loop using indirect function pointers.
- **Section 5**: Mention the "Chaos Trap" connection between Seed Orchestrator and VM V-Table.

#### 2. README.md
- Update "Layer 3" description to mention "Randomized V-Table".
- Add note about "Fail-Deadly" VM behavior.
