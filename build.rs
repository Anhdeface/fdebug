// build.rs
#![allow(unused_imports)]

use std::env;
use std::fs::File;
use std::io::Write;
use std::path::Path;

fn main() {
    // Generate a random seed at build time for polymorphic opcodes
    let dynamic_seed = generate_random_seed();

    // Create the generated_constants.rs file in the protector directory so it can be imported
    let src_dir = Path::new("src").join("protector").join("tiny_vm");
    let dest_path = src_dir.join("generated_constants.rs");

    // Create the directory if it doesn't exist
    std::fs::create_dir_all(src_dir).unwrap();

    let mut f = File::create(&dest_path).unwrap();

    writeln!(f, "// This file is automatically generated by build.rs").unwrap();
    writeln!(f, "// Do not edit manually\n").unwrap();
    writeln!(f, "// Dynamic seed generated at build time for polymorphic opcodes").unwrap();
    writeln!(f, "pub const DYNAMIC_SEED: u8 = 0x{:02X};", dynamic_seed).unwrap();

    // Tell cargo to rerun this build script if something changes
    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=src/protector/tiny_vm.rs");
}

// Function to generate a pseudo-random seed based on build environment
fn generate_random_seed() -> u8 {
    use std::time::{SystemTime, UNIX_EPOCH};

    // Get current time in nanoseconds as a source of randomness
    let now = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .expect("Time went backwards")
        .as_nanos();

    // Use the last 8 bits of the timestamp plus some environmental factors
    let mut seed = (now & 0xFF) as u8;

    // Add some environmental entropy
    if let Ok(pwd) = env::current_dir() {
        seed ^= pwd.to_string_lossy().len() as u8;
    }

    // Add cargo profile to the mix
    if let Ok(profile) = env::var("PROFILE") {
        seed ^= profile.bytes().fold(0u8, |acc, b| acc.wrapping_add(b));
    }

    // Ensure the seed is not zero (which could lead to predictable opcodes)
    if seed == 0 {
        seed = 0x42; // Default fallback
    }

    seed
}